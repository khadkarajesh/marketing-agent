{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Analyze current codebase and stack",
        "description": "Scan project files to confirm framework (Vite/Next), TypeScript setup, and any existing UI/components to align implementation.",
        "details": "- Use ripgrep/glob to inspect files: package.json, tsconfig.json, vite/next config, src/* entries.\n- Identify existing styles (Tailwind/CSS), component patterns, and whether pdfjs or audio libs are present.\n- Document findings (stack, entry points, gaps) to inform subsequent tasks.\n- Do not modify code in this task.",
        "testStrategy": "Verification is visual: confirm existence of key files (package.json, src/main.tsx or pages/_app.tsx), and note whether React+TS is already configured.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Scan repository structure and key config files to identify framework and tooling",
            "description": "List files and directories, focusing on package.json, tsconfig, vite/next configs, and src entries.",
            "dependencies": [],
            "details": "Use Glob and Grep equivalents via shell tools to enumerate the project. Capture existence of package.json, tsconfig.json/tsconfig.*, vite.config.*, next.config.*, postcss/tailwind configs, and src/* structure. Do not modify any files.",
            "status": "pending",
            "testStrategy": "Confirm files are detected and paths recorded."
          },
          {
            "id": 2,
            "title": "Inspect package.json to confirm framework, scripts, and major dependencies",
            "description": "Open package.json to determine framework (Vite/Next), React/TypeScript versions, and scripts.",
            "dependencies": [
              1
            ],
            "details": "Read package.json; check dependencies (e.g., react, react-dom, next, vite, @vitejs/plugin-react), devDependencies (TypeScript, ts-node), and scripts (dev/build/start indicating Vite or Next). Note presence of testing libraries and tooling.",
            "status": "pending",
            "testStrategy": "Verify conclusions align with package.json contents and scripts."
          },
          {
            "id": 3,
            "title": "Assess TypeScript configuration and source entry points",
            "description": "Review tsconfig files and main entry files to understand compiler options and app bootstrap.",
            "dependencies": [
              1,
              2
            ],
            "details": "Open tsconfig.json/tsconfig.* to review target, jsx, paths, strictness. Locate src/main.tsx or src/index.tsx (Vite/CRA) or pages/_app.tsx/app dir (Next). Identify app root component, routing approach, and any alias paths.",
            "status": "pending",
            "testStrategy": "Confirm identified entry files exist and compile settings are documented."
          },
          {
            "id": 4,
            "title": "Identify styling approach and UI component patterns",
            "description": "Detect Tailwind, CSS modules, or styled-components and existing shared components.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Search for tailwind.config.js, postcss.config.js, global.css, *.module.css, styled-components usage, and component directories under src/components. Note naming conventions, props patterns, and any design system in use.",
            "status": "pending",
            "testStrategy": "Presence of config files and example components validates findings."
          },
          {
            "id": 5,
            "title": "Check for media/PDF/audio libraries and summarize findings",
            "description": "Search for pdfjs, audio, or WebSocket usage and produce a concise report of stack and gaps.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Grep dependencies and source for pdfjs-dist, react-pdf, wavesurfer, Web Audio API, navigator.mediaDevices, or WebSocket usage. Create a written summary covering framework, TypeScript status, styling, component patterns, and any media libs; list gaps relevant to future tasks. No code changes.",
            "status": "pending",
            "testStrategy": "Manually verify search hits and ensure the summary matches codebase reality."
          }
        ]
      },
      {
        "id": 2,
        "title": "Define shared TypeScript types and config constants",
        "description": "Create core types for conversation, PDFs, and the Client Search payload; add config placeholders for API keys and URLs.",
        "details": "- Add `src/types.ts` with:\n  - `export type Role = 'agent' | 'user'`\n  - `export interface ConversationTurn { role: Role; text: string; timestamp?: number }`\n  - `export interface PdfImage { filename: string; pageNumber: number; dataUrl: string }`\n  - `export interface ClientSearchPayload { conversationTranscript: string; conversationProblemHint?: string; conversationSolutionHint?: string; pdfImages: PdfImage[] }`\n- Add `src/config.ts` exporting:\n  - `export const ELEVENLABS_API_KEY = import.meta.env.VITE_ELEVENLABS_API_KEY ?? '' // TODO: set in .env`\n  - `export const ELEVENLABS_AGENT_ID = import.meta.env.VITE_ELEVENLABS_AGENT_ID ?? '' // TODO`\n  - `export const CLIENT_SEARCH_URL = import.meta.env.VITE_CLIENT_SEARCH_URL ?? '/client-search' // TODO`\n- Export `export const ELEVENLABS_AGENT_PROMPT = \"<exact prompt from PRD>\"` as a string constant for reuse.",
        "testStrategy": "Type-check passes; files compile when imported by components/hooks. Confirm env values read via `VITE_*`.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Confirm Vite root and scan for existing types/config modules",
            "description": "Inspect the frontend project to verify Vite root, search for existing types.ts/config.ts, and note current env usage patterns.",
            "dependencies": [],
            "details": "Use ripgrep to scan the repo: check for 'frontend/vite.config.ts' to confirm Vite root, list 'frontend/src' for existing shared modules, and grep for 'import.meta.env' or 'VITE_' usage. Record that no existing types/config modules are present and decide on file paths 'frontend/src/types.ts' and 'frontend/src/config.ts'.",
            "status": "pending",
            "testStrategy": "None"
          },
          {
            "id": 2,
            "title": "Create shared TypeScript types in frontend/src/types.ts",
            "description": "Add the core shared types used across the app for conversation, PDFs, and client search payload.",
            "dependencies": [
              1
            ],
            "details": "Create 'frontend/src/types.ts' and export: (1) type Role = 'agent' | 'user'; (2) interface ConversationTurn { role: Role; text: string; timestamp?: number }; (3) interface PdfImage { filename: string; pageNumber: number; dataUrl: string }; (4) interface ClientSearchPayload { conversationTranscript: string; conversationProblemHint?: string; conversationSolutionHint?: string; pdfImages: PdfImage[] }. Ensure named exports and consistent formatting.",
            "status": "pending",
            "testStrategy": "Run a type-check/build to ensure the new file compiles with project TS settings (strict, noUnused*)."
          },
          {
            "id": 3,
            "title": "Add config constants with Vite env fallbacks in frontend/src/config.ts",
            "description": "Expose env-backed constants for API keys/URLs and include the agent prompt placeholder for later replacement.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create 'frontend/src/config.ts' exporting: ELEVENLABS_API_KEY = import.meta.env.VITE_ELEVENLABS_API_KEY ?? ''; ELEVENLABS_AGENT_ID = import.meta.env.VITE_ELEVENLABS_AGENT_ID ?? ''; CLIENT_SEARCH_URL = import.meta.env.VITE_CLIENT_SEARCH_URL ?? '/client-search'; ELEVENLABS_AGENT_PROMPT = 'TODO: replace with exact prompt from PRD'. Add TODO comments indicating where to set values in .env and that Task 8 will replace the prompt.",
            "status": "pending",
            "testStrategy": "Type-check by importing the module in a temporary file or running a build to ensure no runtime/type errors related to import.meta.env usage."
          },
          {
            "id": 4,
            "title": "Provide Vite env example file at frontend/.env.example",
            "description": "Add a Vite-specific .env.example for the frontend to document required keys and default URL.",
            "dependencies": [
              3
            ],
            "details": "Create 'frontend/.env.example' with the following keys: VITE_ELEVENLABS_API_KEY=; VITE_ELEVENLABS_AGENT_ID=; VITE_CLIENT_SEARCH_URL=/client-search. Include brief comments on their purpose and note to copy to '.env' or '.env.local' when running locally.",
            "status": "pending",
            "testStrategy": "Manual: copy to 'frontend/.env.local', set sample values, then verify they are accessible via import.meta.env in a quick console.log during dev if needed."
          },
          {
            "id": 5,
            "title": "Verify types/config integration via project type-check/build",
            "description": "Ensure the project compiles cleanly and that the new modules integrate with strict TS and Vite settings.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Run a project-wide type-check/build from the 'frontend' directory. Confirm no unused local warnings introduced, and that imports of 'types.ts' and 'config.ts' (when used by later hooks/components) compile cleanly. Adjust any import paths if necessary.",
            "status": "pending",
            "testStrategy": "Use 'npm run build' or 'vite build' in 'frontend' to validate. Optionally add a dev-only temporary import to assert the modules compile, then remove it to keep 'noUnused*' satisfied."
          }
        ]
      },
      {
        "id": 3,
        "title": "Implement ElevenLabs conversation hook (Context7)",
        "description": "Create a hook that integrates ElevenLabs Conversational Voice/Agent via WebSocket streaming based on Context7 patterns.",
        "details": "- File: `src/hooks/useElevenLabsConversation.ts`.\n- Responsibilities:\n  - State: `isActive`, `turns: ConversationTurn[]`, `error?: string`.\n  - API: `startSession()`, `stopSession()`, optional callbacks `onAgentMessage`, `onUserTranscriptUpdate`.\n  - Integrate ElevenLabs per Context7 docs:\n    - Establish WebSocket to the Conversational/ConvAI endpoint (Context7 URL), authenticate using API key (e.g., `Sec-WebSocket-Protocol: <api-key>` or per Context7 spec). Add TODO with exact header if needed.\n    - On connect, send session/agent init message including `ELEVENLABS_AGENT_ID` or an inline system prompt with `ELEVENLABS_AGENT_PROMPT` per Context7 examples.\n    - Acquire microphone with `navigator.mediaDevices.getUserMedia({ audio: true })` and capture chunks (MediaRecorder or WebAudio PCM) to send as `input_audio_buffer.append`/binary messages as required by Context7.\n    - Handle server messages: user transcript partial/final and agent messages; push `ConversationTurn` entries into state with roles `user` and `agent`.\n    - Implement clean shutdown: stop mic tracks, close socket; handle reconnect/error conditions.\n  - Add clear TODOs for unknown IDs/models/voice; include comments referencing Context7 event names and payload shapes.",
        "testStrategy": "Manual: with valid API key, Start/Stop toggles connection; transcript grows with both roles. Fault-injection: invalid API key or blocked mic results in readable `error` state and no crash.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize hook scaffold and types for ElevenLabs conversation in `src/hooks/useElevenLabsConversation.ts`",
            "description": "Create the hook file (if missing) and define core types and public API signatures for the conversation hook.",
            "dependencies": [],
            "details": "Add the file `src/hooks/useElevenLabsConversation.ts` with exported hook `useElevenLabsConversation(opts?)` including state: `isActive`, `turns: ConversationTurn[]`, `error?: string`. Define `ConversationTurn` type with roles `user` or `agent`, text, timestamps, and optional metadata. Expose `startSession()` and `stopSession()` plus optional callbacks in opts: `onAgentMessage`, `onUserTranscriptUpdate`. Include TODOs for Context7-specific URLs and headers. Ensure no side effects yet.",
            "status": "pending",
            "testStrategy": "Type-checks compile; importing hook in a dummy component shows correct API."
          },
          {
            "id": 2,
            "title": "Implement WebSocket session lifecycle and agent initialization (Context7/ElevenLabs)",
            "description": "Wire up WebSocket connect/disconnect with clean resource management and agent init message per Context7 patterns.",
            "dependencies": [
              1
            ],
            "details": "Inside the hook, implement `startSession()` to open WebSocket to the Context7 ElevenLabs Conversational endpoint. Authenticate using API key via `Sec-WebSocket-Protocol` or Context7-specified header (insert TODO with exact header). On `open`, send session init payload containing `ELEVENLABS_AGENT_ID` or a system prompt fallback with `ELEVENLABS_AGENT_PROMPT`. Track socket in ref, update `isActive`, and store close/error handlers. Implement `stopSession()` to close socket, clear timers, set `isActive=false`, and capture any error state from close events. Add reconnection guard to prevent duplicate sessions.",
            "status": "pending",
            "testStrategy": "Manual: call `startSession()` then `stopSession()`; check `isActive` toggles; simulate failure with invalid key and verify readable `error`."
          },
          {
            "id": 3,
            "title": "Capture microphone audio and stream to server as input buffers",
            "description": "Request microphone permission and stream audio chunks using MediaRecorder/WebAudio to the WebSocket per Context7 event schema.",
            "dependencies": [
              2
            ],
            "details": "On session start, call `navigator.mediaDevices.getUserMedia({ audio: true })`. Use `MediaRecorder` (Opus) or WebAudio PCM fallback to produce chunks. For each chunk, send according to Context7/ElevenLabs spec (e.g., `input_audio_buffer.append` messages or raw binary frames). Implement start/stop of the recorder tied to session start/stop. Ensure tracks are stopped and recorders closed on `stopSession()` and on socket close. Handle permission denial by setting `error` and not crashing. Leave TODO with exact message envelope and mime type required by Context7.",
            "status": "pending",
            "testStrategy": "Manual: grant/deny mic; confirm no crash; with logging enabled, verify chunk send cadence and shutdown stops tracks."
          },
          {
            "id": 4,
            "title": "Parse server messages for transcripts and agent replies; update `turns` state",
            "description": "Handle incoming WebSocket messages to build user partial/final transcript turns and agent message turns.",
            "dependencies": [
              2,
              3
            ],
            "details": "Implement `socket.onmessage` to parse JSON and binary frames from Context7. Recognize transcript partial/final events for user (e.g., `transcript.delta` and `transcript.completed`) and agent outputs (e.g., `agent.message.delta`/`completed`). Maintain a transient buffer for partials, pushing final `ConversationTurn` entries into `turns` with role `user` or `agent`. Invoke `onUserTranscriptUpdate` on partials and `onAgentMessage` on agent completions. Add robust guards for unknown event types and set `error` on malformed payloads. Include inline comments mapping Context7 event names to code paths and TODOs where payload shape is uncertain.",
            "status": "pending",
            "testStrategy": "Use mocked message events in a test harness or component to feed sample Context7 payloads; assert state updates and callback invocations."
          },
          {
            "id": 5,
            "title": "Finalize cleanup, edge-case handling, and developer ergonomics",
            "description": "Harden the hook with cleanup logic, reconnection guards, configuration points, and documentation comments.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Ensure all mic tracks and media recorders stop on errors/unmount; close the WebSocket in `useEffect` cleanup. Prevent multiple concurrent sessions with an `isConnecting` ref. Add configurable options (URL, agentId, prompt, voice, model) via hook params or env vars; document expected env keys (e.g., `VITE_ELEVENLABS_API_KEY`, `ELEVENLABS_AGENT_ID`). Add clear TODOs where Context7 specifics are pending. Provide small usage example in comments and return helpers to append synthetic user turns for testing.",
            "status": "pending",
            "testStrategy": "Manual: mount/unmount component using the hook; rapid start/stop cycles do not leak tracks or sockets; verify env-driven config paths."
          }
        ]
      },
      {
        "id": 4,
        "title": "Build VoiceAgentPanel UI",
        "description": "Create a UI component to control the conversation and display a chat-like transcript with live updates.",
        "details": "- File: `src/components/VoiceAgentPanel.tsx`.\n- UI:\n  - Buttons: `Start Conversation` (primary) and `Stop` (danger) toggled by `isActive`.\n  - Status line: `Listening…` when active.\n  - Scrollable transcript view rendering `turns` with role labels.\n- Logic:\n  - Uses `useElevenLabsConversation` hook; wires start/stop.\n  - Build a `conversationTranscript` string by joining turns (maintained at parent or here and exposed).\n  - Optional local heuristic `problemHint`/`solutionHint` extraction by scanning latest user responses for keywords (problem/solution); keep as best-effort hints.\n- Basic error messages for permission/socket failures.",
        "testStrategy": "Render component in isolation with mocked hook to test UI states; manual run to ensure transcript renders and auto-scrolls; check that start/stop buttons enable/disable correctly.",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create VoiceAgentPanel component and directory in frontend/src/components",
            "description": "Set up the base React component file and export to host the conversation controls and transcript UI.",
            "dependencies": [],
            "details": "Create frontend/src/components/VoiceAgentPanel.tsx (and optional VoiceAgentPanel.css). Define typed props (onTranscriptChange?: (t: string) => void, onHintsChange?: (p?: string, s?: string) => void, className?: string). Return a container with placeholder areas for controls, status, and transcript. Ensure it compiles by importing and rendering in frontend/src/App.tsx.",
            "status": "pending",
            "testStrategy": "Manual: import into App and confirm the component renders with placeholder content and no type errors."
          },
          {
            "id": 2,
            "title": "Wire Start/Stop controls and active status using useElevenLabsConversation",
            "description": "Connect the component to the hook API to control session lifecycle and show a live status line.",
            "dependencies": [
              1
            ],
            "details": "Import useElevenLabsConversation from frontend/src/hooks/useElevenLabsConversation (or use a mocked local interface until Task 3 lands). Render a primary Start Conversation button and a danger Stop button; toggle visibility/disabled state by hook.isActive. Call hook.startSession on Start and hook.stopSession on Stop. Show Listening… when isActive. Render hook.error when present (permission/socket failures).",
            "status": "pending",
            "testStrategy": "Mock hook in the component (or pass as prop) to simulate isActive, startSession, stopSession, and error states; verify buttons toggle and status/error text render."
          },
          {
            "id": 3,
            "title": "Implement scrollable transcript view with role labels and auto-scroll",
            "description": "Render conversation turns in a fixed-height, scrollable area with clear role labeling and smooth auto-scroll to latest.",
            "dependencies": [
              2
            ],
            "details": "Map hook.turns: ConversationTurn[] into a list with role badges (Agent/User) and timestamp rendering if available. Wrap the list in a container (e.g., max-height: 50vh; overflow-y: auto). Use a ref + useEffect to scroll into view on updates (e.g., lastItemRef.scrollIntoView). Keep styles minimal in VoiceAgentPanel.css or inline to match project conventions.",
            "status": "pending",
            "testStrategy": "Simulate turns changes via a mocked hook; confirm new messages appear and container auto-scrolls to the latest item; visually check role badges and timestamps."
          },
          {
            "id": 4,
            "title": "Build and expose conversationTranscript string from turns",
            "description": "Join the turns into a single transcript string and expose it to parent via callback when it changes.",
            "dependencies": [
              3
            ],
            "details": "Compute conversationTranscript with useMemo by joining turns like `${role}: ${text}` per line. Use useEffect to call onTranscriptChange?.(conversationTranscript) when turns change. Keep formatting consistent and avoid extra whitespace; handle empty states safely.",
            "status": "pending",
            "testStrategy": "Mock turns and assert via console/log that onTranscriptChange fires with the expected formatted string after each update."
          },
          {
            "id": 5,
            "title": "Add heuristic problemHint/solutionHint extraction and surface via callback",
            "description": "Extract lightweight hints by scanning recent user turns for problem/solution keywords and emit updates to the parent.",
            "dependencies": [
              4
            ],
            "details": "Implement a keyword-based heuristic over the last N user turns (e.g., problem/issue/error/failing vs fix/solution/resolve/works). Use useMemo/useEffect to compute problemHint and solutionHint and call onHintsChange?.(problemHint, solutionHint) when updated. Make it resilient to empty turns and avoid spamming updates with basic debouncing.",
            "status": "pending",
            "testStrategy": "Unit-like test in isolation: feed sample user turns and verify computed hints; manual verification in App by logging onHintsChange output and ensuring no crashes on empty input."
          }
        ]
      },
      {
        "id": 5,
        "title": "Implement PDF upload and PDF→image conversion",
        "description": "Allow multiple PDF uploads and convert each page to image Data URLs in the browser using PDF.js.",
        "details": "- Add `pdfjs-dist` if not present; configure worker: `pdfjsLib.GlobalWorkerOptions.workerSrc = new URL('pdf.worker.min.js', import.meta.url).toString()` or CDN per build.\n- File: `src/utils/pdf.ts` with `export async function pdfToImages(file: File): Promise<PdfImage[]>`:\n  - Read file to ArrayBuffer.\n  - `const pdf = await getDocument({ data: arrayBuffer }).promise`.\n  - Loop pages: `const page = await pdf.getPage(i)`; render to offscreen canvas at scale 1.5–2.0; `canvas.toDataURL('image/png')`.\n  - Return `PdfImage[]` including filename and pageNumber.\n- Component: `src/components/PdfUploadPanel.tsx`:\n  - Input (accept `.pdf`, multiple) and drag-and-drop zone.\n  - Show file list and per-file progress; handle errors.\n  - Aggregate results and expose `pdfImages` upward via props/callback.",
        "testStrategy": "Upload 1–2 PDFs; verify image count == page count; throttle network off to ensure no backend calls occur; test corrupted PDF to see handled error state.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Analyze repository for existing PDF utilities, types, and upload patterns",
            "description": "Search the codebase to find any current PDF-related utilities, types, worker setups, or upload UI to align implementation and avoid duplication.",
            "dependencies": [],
            "details": "Use ripgrep to look for files such as `src/utils/pdf.ts`, `src/types.ts`, `src/components/*Upload*.tsx`, and any `pdfjs-dist` references. Identify existing type definitions (e.g., `PdfImage`), progress UI patterns, and worker configuration to follow established conventions.",
            "status": "pending",
            "testStrategy": "Review search results and note findings. No code execution required."
          },
          {
            "id": 2,
            "title": "Ensure pdfjs-dist is installed and configure the PDF.js worker",
            "description": "Verify `pdfjs-dist` is present and implement a robust worker configuration suitable for the current build tooling (e.g., Vite/React).",
            "dependencies": [
              1
            ],
            "details": "If missing, add `pdfjs-dist` to dependencies. Create a small initializer (e.g., `src/utils/pdfWorker.ts`) that sets `pdfjsLib.GlobalWorkerOptions.workerSrc = new URL('pdf.worker.min.js', import.meta.url).toString()`. Import this initializer once (e.g., in `src/main.tsx` or within the `pdf.ts` utility prior to first use) to ensure the worker is available.",
            "status": "pending",
            "testStrategy": "Load a trivial PDF via `getDocument` and confirm the worker initializes without console errors or network requests to undefined paths."
          },
          {
            "id": 3,
            "title": "Implement pdfToImages utility with page rendering and error handling",
            "description": "Create `src/utils/pdf.ts` exporting `async function pdfToImages(file: File): Promise<PdfImage[]>` to render each PDF page to a PNG Data URL.",
            "dependencies": [
              2
            ],
            "details": "Read the file via `await file.arrayBuffer()`. Call `const pdf = await getDocument({ data: arrayBuffer }).promise`. Loop pages `for (let i=1; i<=pdf.numPages; i++) { const page = await pdf.getPage(i); }`. Render each page to an offscreen canvas using a scale of 1.5–2.0 with `page.getViewport({ scale })`, then `canvas.toDataURL('image/png')`. Return `PdfImage[]` items `{ filename: file.name, pageNumber: i, dataUrl }`. Catch and rethrow with a user-friendly error message for corrupted PDFs.",
            "status": "pending",
            "testStrategy": "Unit test with a small valid PDF and a corrupted file. Assert output length equals page count and that corrupted input yields a handled error without crashing."
          },
          {
            "id": 4,
            "title": "Create PdfUploadPanel with multi-file input, drag-and-drop, and progress UI",
            "description": "Add `src/components/PdfUploadPanel.tsx` to accept multiple PDFs, process each with `pdfToImages`, display per-file progress, and surface errors.",
            "dependencies": [
              3
            ],
            "details": "Implement a file input (`accept='.pdf'`, `multiple`) and a drag-and-drop zone. Maintain local state for queued files, per-file progress, and errors. Process files sequentially or with limited concurrency. Aggregate `PdfImage[]` across all files and expose via `onChange(pdfImages: PdfImage[])` callback. Include basic accessibility and keyboard support.",
            "status": "pending",
            "testStrategy": "Manual UI test: upload 1–2 PDFs and verify total images match total pages. Toggle offline mode to ensure no backend calls occur. Drop a corrupted PDF to confirm error display and resilience."
          },
          {
            "id": 5,
            "title": "Integrate PdfUploadPanel and plumb pdfImages to consumer components",
            "description": "Mount the new panel in the appropriate parent (e.g., ClientSearchPanel or a shared page), maintain `pdfImages` state, and wire it into downstream flows.",
            "dependencies": [
              4
            ],
            "details": "Add state `const [pdfImages, setPdfImages] = useState<PdfImage[]>([])` in the parent, render `<PdfUploadPanel onChange={setPdfImages} />`, and pass `pdfImages` to consumers. Confirm types match `src/types.ts` and that other features (e.g., Client Search) can access the images. Update any relevant props/contracts.",
            "status": "pending",
            "testStrategy": "End-to-end manual test: upload PDFs, verify `pdfImages` state updates, confirm dependent features receive images, and check no unhandled errors appear in the console."
          }
        ]
      },
      {
        "id": 6,
        "title": "Lift and centralize app state",
        "description": "Maintain conversation and PDF data at the App level for cross-panel access and final payload assembly.",
        "details": "- File: `src/App.tsx` (or appropriate root):\n  - State: `turns`, `conversationTranscript`, `problemHint`, `solutionHint`, `pdfImages`.\n  - Render three panels: `VoiceAgentPanel`, `PdfUploadPanel`, `ClientSearchPanel`.\n  - Provide props or React Context to share/update state.\n- Add simple layout and styles matching existing project conventions (CSS modules/Tailwind).",
        "testStrategy": "Manual: engage conversation, upload PDFs; ensure downstream panel previews reflect the latest state; verify no prop drilling bugs via type checks.",
        "priority": "medium",
        "dependencies": [
          4,
          5
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create AppState types and Context scaffolding",
            "description": "Define TypeScript interfaces and a React Context skeleton for centralized app state to be shared across panels.",
            "dependencies": [],
            "details": "Add frontend/src/types/app.ts with ConversationTurn and PdfImage interfaces. Create frontend/src/context/AppStateContext.tsx exporting AppStateContext, AppStateProvider, and useAppState(). Context shape includes: turns, conversationTranscript, problemHint, solutionHint, pdfImages, plus setters and helper actions.",
            "status": "pending",
            "testStrategy": "Type-check the new files; ensure the context and types compile without errors."
          },
          {
            "id": 2,
            "title": "Lift state into App and provide via Context",
            "description": "Initialize and manage shared state at the App level and expose it through the Context provider.",
            "dependencies": [
              1
            ],
            "details": "Update frontend/src/App.tsx to wrap its children with <AppStateProvider>. Initialize state for turns, problemHint, solutionHint, pdfImages and derive conversationTranscript from turns (e.g., useMemo). Populate provider value with state and setters.",
            "status": "pending",
            "testStrategy": "Run type checks and ensure App renders with the provider without runtime errors."
          },
          {
            "id": 3,
            "title": "Scaffold panel components and connect to Context",
            "description": "Create minimal VoiceAgentPanel, PdfUploadPanel, and ClientSearchPanel components wired to read/write shared state via Context.",
            "dependencies": [
              2
            ],
            "details": "Add frontend/src/components/VoiceAgentPanel.tsx, PdfUploadPanel.tsx, and ClientSearchPanel.tsx. Each uses useAppState() to read required fields and call setter actions; keep logic minimal (placeholders) so compile succeeds.",
            "status": "pending",
            "testStrategy": "Render the panels in isolation via story or simple test page and verify they can read from and invoke context setters without TypeScript errors."
          },
          {
            "id": 4,
            "title": "Render panels in App and add basic layout/styles",
            "description": "Compose the three panels inside App and apply simple CSS-based layout consistent with the project’s existing CSS files.",
            "dependencies": [
              3
            ],
            "details": "Modify frontend/src/App.tsx to render the three panels in a responsive grid. Update frontend/src/App.css (and/or index.css) to include a grid container class and basic panel styling matching current CSS conventions (no Tailwind).",
            "status": "pending",
            "testStrategy": "Manual: load the app and verify the three panels render correctly with expected layout and no console errors."
          },
          {
            "id": 5,
            "title": "Verify cross-panel state flow and payload readiness",
            "description": "Manually validate that updates in one panel reflect in others and that shared state matches the final payload needs.",
            "dependencies": [
              4
            ],
            "details": "Interact with placeholder controls: simulate adding turns, setting hints, and adding pdfImages to confirm conversationTranscript and counts update across panels. Ensure ClientSearchPanel can access all required fields for payload assembly.",
            "status": "pending",
            "testStrategy": "Manual: run frontend dev server; update state in one panel and observe changes in others; ensure TypeScript types prevent prop-drilling mistakes."
          }
        ]
      },
      {
        "id": 7,
        "title": "Implement Client Search POST flow",
        "description": "Create a panel to construct FormData and POST conversation and PDF images to the backend `/client-search`.",
        "details": "- File: `src/components/ClientSearchPanel.tsx`.\n- Disable `Run Client Search` button until there is either a non-empty transcript or at least one `PdfImage`.\n- On click:\n  - Build `FormData`:\n    - `formData.append('conversationTranscript', conversationTranscript)`.\n    - Optionally append `conversationProblemHint` and `conversationSolutionHint`.\n    - For each image: append `pdfImages[index][filename]`, `[pageNumber]`, `[dataUrl]` as outlined in PRD.\n  - `await fetch(CLIENT_SEARCH_URL, { method: 'POST', body: formData })` with try/catch and a timeout controller.\n- Show loading, success, and error banners; surface non-200 status as errors.\n- Note: strictly client-side; no backend code added.",
        "testStrategy": "Point `CLIENT_SEARCH_URL` to a test receiver; verify payload structure and fields; simulate network error (offline) and confirm UI error state; confirm button disable logic works.",
        "priority": "high",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Inventory codebase for ClientSearchPanel, types, and config constants",
            "description": "Scan the repository to find ClientSearchPanel.tsx, related types like PdfImage, and CLIENT_SEARCH_URL configuration to understand current structure and patterns.",
            "dependencies": [],
            "details": "Use `rg --files` and `rg \"ClientSearchPanel|CLIENT_SEARCH_URL|PdfImage|Client Search\" -n src` to locate relevant files. Read `src/components/ClientSearchPanel.tsx` (if exists) plus any `src/types.ts` and `src/config.ts` to confirm available types, props, state, banner/toast components, and fetch utilities.",
            "status": "pending",
            "testStrategy": "Confirm actual file paths and note any existing utilities or components that will be reused."
          },
          {
            "id": 2,
            "title": "Assess ClientSearchPanel state, props, and UI entry points for POST flow",
            "description": "Open ClientSearchPanel.tsx to identify where transcript, hints, and pdfImages live, and determine where to attach the POST action and disable logic.",
            "dependencies": [
              1
            ],
            "details": "Inspect current state variables (conversationTranscript, conversationProblemHint, conversationSolutionHint, pdfImages). Identify the Run Client Search button and confirm where to add `disabled` conditions and click handler. Note any existing loading/success/error UI patterns (e.g., Alert, Banner, Toast) to reuse.",
            "status": "pending",
            "testStrategy": "Verify presence of the button and capture the exact variable names for transcript and pdf images for the next step."
          },
          {
            "id": 3,
            "title": "Implement FormData construction per PRD and POST with timeout",
            "description": "Create the click handler to build FormData using transcript, optional hints, and pdfImages fields and POST to CLIENT_SEARCH_URL with AbortController timeout and robust error handling.",
            "dependencies": [
              2
            ],
            "details": "In ClientSearchPanel.tsx, on click: `const formData = new FormData(); formData.append('conversationTranscript', conversationTranscript);` Conditionally append `conversationProblemHint` and `conversationSolutionHint` if non-empty. For each image, append `pdfImages[index][filename]`, `pdfImages[index][pageNumber]`, `pdfImages[index][dataUrl]` per PRD. Use `const ac = new AbortController(); set timeout to abort`; `await fetch(CLIENT_SEARCH_URL, { method: 'POST', body: formData, signal: ac.signal })`. Treat non-2xx as errors and surface messages.",
            "status": "pending",
            "testStrategy": "Point CLIENT_SEARCH_URL to a test receiver; inspect multipart fields; simulate timeout and network error to ensure handler sets error state."
          },
          {
            "id": 4,
            "title": "Add button gating and request banners for loading, success, and error",
            "description": "Disable Run Client Search unless transcript is non-empty or there is at least one PdfImage, and display banners reflecting request status and errors (including non-200).",
            "dependencies": [
              3
            ],
            "details": "Compute `const canRun = conversationTranscript.trim().length > 0 || pdfImages.length > 0;` Bind `disabled={!canRun || isLoading}`. Track `isLoading`, `successMessage`, `errorMessage` in component state. On success show success banner; on error show error banner with server status/text and any body message. Clear banners between runs.",
            "status": "pending",
            "testStrategy": "Verify disabled state toggles as user types transcript or adds/removes images; confirm banners show for loading, success, non-200, and offline scenarios."
          },
          {
            "id": 5,
            "title": "Extract FormData builder and align with project conventions",
            "description": "Refactor to extract a small `buildClientSearchFormData` helper for testability and reuse, and ensure code follows existing project patterns for fetch and UI feedback.",
            "dependencies": [
              4
            ],
            "details": "Create a local helper (or in `src/utils/*` if appropriate) to build FormData from the panel state; keep field names exactly as specified. If a project-wide fetch wrapper or Banner/Alert component exists, replace ad-hoc code to match conventions. Add minimal unit tests for the helper if a test framework exists; otherwise, add runtime assertions/logging in dev.",
            "status": "pending",
            "testStrategy": "Write unit tests to validate required and optional fields and image field naming; run component test for button enable logic if available, else manually verify during development."
          }
        ]
      },
      {
        "id": 8,
        "title": "Embed agent prompt and configuration documentation",
        "description": "Ensure the PRD’s agent prompt is embedded verbatim and add top-level README instructions.",
        "details": "- In `src/config.ts`, export `ELEVENLABS_AGENT_PROMPT` string exactly (or near-exact) as specified.\n- Create/Update `README.md` with:\n  - How to run the app (e.g., Vite `npm run dev`).\n  - Where to set `.env` keys: `VITE_ELEVENLABS_API_KEY`, `VITE_ELEVENLABS_AGENT_ID`, `VITE_CLIENT_SEARCH_URL`.\n  - Notes on ElevenLabs Context7 integration, placeholders to replace, and limitations.\n- Add clear TODO comments near ElevenLabs connection showing where to paste IDs/voice/model.",
        "testStrategy": "Open README and confirm steps are actionable; check that the prompt constant is consumed by the hook; lint/type-check passes.",
        "priority": "medium",
        "dependencies": [
          2,
          3,
          7
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Explore repo to locate config, README, and ElevenLabs references",
            "description": "List files and grep for ElevenLabs/Context7 usage to understand current structure and where to embed the prompt and docs.",
            "dependencies": [],
            "details": "Use ripgrep to enumerate files and search for: 'src/config.ts', 'README.md', '.env', 'VITE_ELEVENLABS_', 'Context7', 'useElevenLabsConversation', 'WebSocket'. Record relevant paths for follow‑up.",
            "status": "pending",
            "testStrategy": "Verify each referenced path exists via rg outputs; note any missing files for creation."
          },
          {
            "id": 2,
            "title": "Review src/config.ts and typings to confirm config patterns",
            "description": "Open src/config.ts (and types if present) to learn export style, env var usage, and whether ELEVENLABS_AGENT_PROMPT already exists.",
            "dependencies": [
              1
            ],
            "details": "Check for existing constants (API key, agent ID, client search URL) and how they read env via Vite (import.meta.env). Identify the exact location and naming convention to add ELEVENLABS_AGENT_PROMPT without breaking imports.",
            "status": "pending",
            "testStrategy": "Confirm current exports compile conceptually and list the precise insertion point for the new prompt constant."
          },
          {
            "id": 3,
            "title": "Assess README.md and .env handling to define documentation gaps",
            "description": "Open README.md to see if run instructions and environment keys are already documented; identify missing sections required by the task.",
            "dependencies": [
              1
            ],
            "details": "Look for npm/yarn/pnpm run commands (e.g., npm run dev), environment setup instructions, and any ElevenLabs notes. Compare against required keys: VITE_ELEVENLABS_API_KEY, VITE_ELEVENLABS_AGENT_ID, VITE_CLIENT_SEARCH_URL. Note gaps to fill.",
            "status": "pending",
            "testStrategy": "Confirm README presence and content; if absent, plan to create with required sections."
          },
          {
            "id": 4,
            "title": "Trace ElevenLabs integration to place TODOs and prompt usage",
            "description": "Find the ElevenLabs hook or connection code that will consume the prompt and add clear TODO comments for IDs/voice/model locations.",
            "dependencies": [
              2
            ],
            "details": "Search in src/hooks and components for WebSocket/ElevenLabs logic (e.g., useElevenLabsConversation). Determine import path for ELEVENLABS_AGENT_PROMPT and exact lines to insert TODOs about pasting Agent ID, voice, and model per Context7.",
            "status": "pending",
            "testStrategy": "Ensure the identified files exist and imports will resolve from src/config.ts; note targeted line ranges."
          },
          {
            "id": 5,
            "title": "Prepare precise edit plan for embedding prompt and updating docs",
            "description": "Draft concrete changes: export ELEVENLABS_AGENT_PROMPT verbatim in src/config.ts, update README with run steps, env keys, Context7 notes, and add TODO comments near the ElevenLabs connection code.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Align names and formatting with repo conventions. README must include: how to run (Vite dev), where to set VITE_* keys, Context7 integration notes, placeholders to replace, and limitations. Ensure prompt constant is referenced where needed.",
            "status": "pending",
            "testStrategy": "Validate that planned edits are consistent, actionable, and won’t break type/lint checks; verify that the prompt constant will be consumed by the hook."
          }
        ]
      },
      {
        "id": 9,
        "title": "Robust error handling and UX polish",
        "description": "Improve resilience and UX for permission errors, socket failures, PDF errors, and POST failures; add minimal styling.",
        "details": "- Mic: detect and display friendly message on permission denial; allow retry.\n- Socket: display reconnect tip; log details to console with safe redaction; ensure `stopSession` cleans resources.\n- PDF: per-file error with filename; continue processing others.\n- POST: show response status; link to retry; guard against double-click with in-flight flag.\n- Auto-scroll transcript; simple responsive layout; keep styles consistent with current project (CSS or Tailwind).",
        "testStrategy": "Manual fault-injection: deny mic, invalid API key, upload broken PDF, toggle offline before POST. Ensure UI remains responsive and informative.",
        "priority": "medium",
        "dependencies": [
          4,
          5,
          7,
          8
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Scan repo for mic, socket, PDF, POST, and styling code paths",
            "description": "Enumerate files and search code to identify exact components/hooks/utilities handling mic permissions, WebSockets, PDF processing, POST calls, and styling setup.",
            "dependencies": [],
            "details": "Use ripgrep to locate patterns: getUserMedia, WebSocket, fetch/axios, pdf/pdfjs, Tailwind/config, transcript rendering. Read key files to confirm state shapes, error conventions, and UI patterns to follow.",
            "status": "pending",
            "testStrategy": null
          },
          {
            "id": 2,
            "title": "Implement mic permission denial UX with retry",
            "description": "Add friendly user messaging and a retry flow for mic permission denials or missing devices without duplicating streams.",
            "dependencies": [
              1
            ],
            "details": "Catch NotAllowedError/NotFoundError in mic flow; add error state with visible banner/dialog and a ‘Try again’ that re-requests permission safely; ensure previous tracks are stopped and state reset before retry.",
            "status": "pending",
            "testStrategy": null
          },
          {
            "id": 3,
            "title": "Improve socket failure UX and ensure stopSession resource cleanup",
            "description": "Show reconnect guidance for socket errors, redact sensitive values in logs, and make stopSession idempotently clean up sockets/listeners/timers/tracks.",
            "dependencies": [
              1,
              2
            ],
            "details": "Handle onerror/onclose with user-facing reconnect tip; console.log with redaction of API keys/tokens; in stopSession close socket, remove listeners, clear timers, stop media tracks; guard to avoid double-cleanup.",
            "status": "pending",
            "testStrategy": null
          },
          {
            "id": 4,
            "title": "Add per-file PDF error reporting with continue-on-error",
            "description": "Display filename-specific errors for PDFs that fail to parse/render while continuing to process remaining files.",
            "dependencies": [
              1
            ],
            "details": "Wrap per-file PDF parsing in try/catch; collect successes and errors with filenames; render inline per-file error messages near upload list/cards; ensure a single failure does not abort the batch.",
            "status": "pending",
            "testStrategy": null
          },
          {
            "id": 5,
            "title": "Harden POST flows and polish UX (status, retry, in-flight, auto-scroll, responsive)",
            "description": "Show POST response status and message, provide a retry control, prevent double submissions, auto-scroll transcript, and add minimal responsive styles consistent with current project.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Introduce isSubmitting flag to disable buttons; capture/display HTTP status and error text; implement retry that safely replays last request; auto-scroll transcript via ref on new entries; apply small Tailwind/CSS classes for alerts and layout.",
            "status": "pending",
            "testStrategy": null
          }
        ]
      },
      {
        "id": 10,
        "title": "Light verification scripts and optional tests",
        "description": "Add a manual verification checklist and optional UI smoke tests (no real audio) to validate the end-to-end flow.",
        "details": "- Create `docs/verification.md` with steps to:\n  - Start dev server, set env vars, run a short conversation, upload PDFs, call Client Search.\n- Optional: add a minimal e2e or component test (e.g., Playwright/Cypress or React Testing Library) to confirm panels render and button enablement logic without invoking real APIs (mock hooks/fetch).",
        "testStrategy": "Follow checklist and ensure each step passes; run the smoke test (if added) to confirm core UI elements exist and basic interactions work.",
        "priority": "low",
        "dependencies": [
          9
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Scan repository to detect framework and testing setup",
            "description": "Enumerate files and inspect package.json to identify the React stack and any existing testing/e2e tools to align verification steps.",
            "dependencies": [],
            "details": "Use ripgrep to list files; open package.json to review scripts/dependencies; search for Vitest/Jest/Cypress/Playwright configuration files to select the minimal harness.",
            "status": "pending",
            "testStrategy": "Confirm detection by verifying package.json entries and presence of config files."
          },
          {
            "id": 2,
            "title": "Locate UI components and hooks for smoke tests",
            "description": "Search for panel components and hooks (e.g., VoiceAgentPanel, useElevenLabsConversation, pdfToImages) and read them to choose stable targets with clear enable/disable logic.",
            "dependencies": [
              1
            ],
            "details": "Search src for components/hooks; read code to understand state/props patterns; pick elements with predictable states to assert using mocks.",
            "status": "pending",
            "testStrategy": "Ensure at least one renderable component or hook target is identified and documented with its path."
          },
          {
            "id": 3,
            "title": "Create docs/verification.md manual checklist",
            "description": "Author a step-by-step manual guide covering dev server startup, env vars, a short conversation simulation, PDF upload, and Client Search without real audio or network calls.",
            "dependencies": [
              1,
              2
            ],
            "details": "Tailor instructions to detected scripts/env names; include explicit pass/fail criteria, troubleshooting, and notes on using mocks to avoid real APIs.",
            "status": "pending",
            "testStrategy": "Dry-run the checklist locally and verify that every step is actionable and unblocks the next."
          },
          {
            "id": 4,
            "title": "Configure minimal smoke testing harness",
            "description": "Set up or adapt the smallest viable test runner (prefer Vitest+React Testing Library if present; otherwise minimal Playwright/Cypress) with mocks to avoid audio/network.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Add test setup and utilities (RTL providers, fetch mocks); if no unit test tooling exists, scaffold a minimal e2e config limited to render checks and state toggles.",
            "status": "pending",
            "testStrategy": "Run the test runner with a placeholder test to validate the setup is green."
          },
          {
            "id": 5,
            "title": "Implement smoke tests and npm scripts",
            "description": "Write tests to verify core panels render and buttons enable/disable correctly with mocked hooks/fetch; add npm scripts and README pointers to run verification.",
            "dependencies": [
              4
            ],
            "details": "Create 1–2 smoke tests for panel rendering and interactions; add scripts `test:smoke` and `verify:manual`; link docs/verification.md from README for discoverability.",
            "status": "pending",
            "testStrategy": "Execute `npm run test:smoke` successfully and confirm the README link to docs/verification.md works."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-11-15T12:59:45.278Z",
      "updated": "2025-11-15T12:59:45.279Z",
      "description": "Tasks for master context"
    }
  }
}